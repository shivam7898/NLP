# NLP Basics {#p01}

```{r 'P01', include=FALSE, cache=FALSE}
sys.source(here::here("code", "A00Knitr.R"), envir = knitr::knit_global())
sys.source(here::here("code", "A01Packages.R"), envir = knitr::knit_global())
sys.source(here::here("code", "A02AllUDF.R"), envir = knitr::knit_global())
reticulate::source_python(here::here("code", "B01Modules.py"))
```

## Data: Krackhardt Kite {#kite-p01 .tabset .tabset-fade}

### Glance {.unlisted .unnumbered}

\textcolor{pink}{Please import the "P01-KM-Week1.xlsx" and "P01-KM-Week4.xlsx"}

- About: 18 Edges and 10 Vertices

```{r 'P01-CSV-Kite', include=FALSE}
loc_src <- here("data", "P01-Kite.csv")
loc_rds <- here("data", "P01-Kite.rds")
if(FALSE | !file.exists(loc_rds)) {
  # #Read Adjacency Matrix from CSV
  aa <- read_csv(loc_src, show_col_types = FALSE)
  # #Columns To RowNames | Named Matrix |
  aa <- aa |> 
    column_to_rownames(var = "Nodes") |> 
    as.matrix.data.frame(rownames.force = TRUE)
  # #Save
  p01kite <- aa
  saveRDS(p01kite, loc_rds)
} else { 
  p01kite <- aa <- readRDS(loc_rds)
}
```

```{r 'P01-Structure-Kite'}
str(p01kite)
```

### Import {.unlisted .unnumbered}

```{r 'P01-CSV-Kite-A', eval=FALSE, ref.label=c('P01-CSV-Kite')}
# #Ref another file chunk
```


## Data: KM Network {#km-p01 .tabset .tabset-fade}

### Glance {.unlisted .unnumbered}

\textcolor{pink}{Please import the "P01-KM-Week1.xlsx" and "P01-KM-Week4.xlsx"}

- About: Edges and Vertices of a Class Network at Week 1 and Week 4

```{r 'P01-XL-KM-1', include=FALSE}
loc_src <- here("data", "P01-KM-Week1.xlsx")
loc_rds <- here("data", "P01-KM-Week1.rds")
if(FALSE | !file.exists(loc_rds)) {
  names_aa <- c("Edges", "Vertices")
  # #Verify Excel
  stopifnot(identical(excel_sheets(loc_src), names_aa))
  # #Empty Named List
  aa <- setNames(vector("list", length(names_aa)), nm = names_aa)
  # #Read Excel Sheets
  aa$Edges    <- read_excel(path = loc_src, sheet = "Edges")
  aa$Vertices <- read_excel(path = loc_src, sheet = "Vertices")
  #
  # #Clean Edges
  names_bb <- c("Node_1", "Node_2", "Recognition", "Friendship")
  # #Rename | To Factor |
  bb <- aa$Edges |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(starts_with("vertex_"), factor)) |> 
    mutate(across(c(recognition, friendship), factor, levels = c(0, 1), labels = c("No", "Yes")))
  # #Rename
  names(bb) <- names_bb
  aa$Edges <- bb
  #
  # #Clean Vertices
  names_bb <- c("Node", "Gender", "Status", "ACCT", "IE", "MS_MIS", "MBA", "Group", "Major")
  # #Rename | Replace NA | Replace x | To Factor |
  bb <- aa$Vertices |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~ replace_na(., "No"))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~gsub("x", "Yes", .))) |> 
    mutate(across(where(is.character), factor))
  # #Rename
  names(bb) <- names_bb
  aa$Vertices <- bb
  #
  # #Save
  p01km_1 <- aa
  saveRDS(p01km_1, loc_rds)
} else { 
  p01km_1 <- aa <- readRDS(loc_rds)
}
```


```{r 'P01-XL-KM-4', include=FALSE}
loc_src <- here("data", "P01-KM-Week4.xlsx")
loc_rds <- here("data", "P01-KM-Week4.rds")
if(FALSE | !file.exists(loc_rds)) {
  names_aa <- c("Edges", "Vertices")
  # #Verify Excel
  stopifnot(identical(excel_sheets(loc_src), names_aa))
  # #Empty Named List
  aa <- setNames(vector("list", length(names_aa)), nm = names_aa)
  # #Read Excel Sheets
  aa$Edges    <- read_excel(path = loc_src, sheet = "Edges")
  aa$Vertices <- read_excel(path = loc_src, sheet = "Vertices")
  #
  # #Clean Edges
  names_bb <- c("Node_1", "Node_2", "Recognition", "Friendship")
  # #Rename | To Factor |
  bb <- aa$Edges |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(starts_with("vertex_"), factor)) |> 
    mutate(across(c(recognition, friendship), factor, levels = c(0, 1), labels = c("No", "Yes")))
  # #Rename
  names(bb) <- names_bb
  aa$Edges <- bb
  #
  # #Clean Vertices
  names_bb <- c("Node", "Gender", "Status", "ACCT", "IE", "MS_MIS", "MBA", "Group", "Major")
  # #Rename | Replace NA | Replace x | To Factor |
  bb <- aa$Vertices |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~ replace_na(., "No"))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~gsub("x", "Yes", .))) |> 
    mutate(across(where(is.character), factor))
  # #Rename
  names(bb) <- names_bb
  aa$Vertices <- bb
  #
  # #Save
  p01km_4 <- aa
  saveRDS(p01km_4, loc_rds)
} else { 
  p01km_4 <- aa <- readRDS(loc_rds)
}
```

```{r 'P01-Dimensions-KM'}
# #Dimensions of Each Sheet: Row 1 (Rows), Row 2 (Columns), Columns (Sheets)
vapply(p01km_1, dim, numeric(2))
vapply(p01km_4, dim, numeric(2))
```

### Structure {.unlisted .unnumbered}

```{r 'P01-Structure-KM'}
str(p01km_1)
str(p01km_4)
```

### Summary {.unlisted .unnumbered}

```{r 'P01-Summary-KM'}
# #Summary of List Objects
lapply(p01km_1, summary)
lapply(p01km_4, summary)
```

### Import {.unlisted .unnumbered}

```{r 'P01-XL-KM-1-A', eval=FALSE, ref.label=c('P01-XL-KM-1')}
# #Ref another file chunk
```

```{r 'P01-XL-KM-4-A', eval=FALSE, ref.label=c('P01-XL-KM-4')}
# #Ref another file chunk
```

### ETC {.unlisted .unnumbered}

```{r 'P01-ETC', include=TRUE, eval=FALSE}
# #Count NA in Columns
if(FALSE) colSums(is.na(bb)) |> as_tibble(rownames = "Cols") |> filter(value > 0)
# #Subset Rows
if(FALSE) bb |> select(1) |> slice(1:10)
# #Comma separated string having each item within quotes for easy pasting as character not objects
if(FALSE) cat('"', paste0(names(which(sapply(bb, is.factor))), collapse = '", "'), '"\n', sep = '')
if(FALSE) cat('"', paste0(levels(bb$Arrival), collapse = '", "'), '"\n', sep = '')
# #Filter
if(FALSE) bb |> filter(is.na(account_length)) |> select(churn, account_length, vmail_plan)
# #Count Yes/No or True/False in ALL such Columns
if(FALSE) bb |> select(churn) |> 
  pivot_longer(everything()) |> count(name, value) |> 
  pivot_wider(names_from = value, values_from = n)
# #Count Unique of all Columns to decide which should be Factors
if(FALSE) bb |> summarise(across(everything(), ~ length(unique(.)))) |> pivot_longer(everything())
# #Summary of Columns of a class: is.factor is.numeric is.character
if(FALSE) bb |> select(where(is.factor)) |> summary()
# #Names and Indices of Columns of class: is.factor is.numeric is.character
if(FALSE) which(sapply(bb, is.factor))
# #Levels of Factor Columns
if(FALSE) lapply(bb[c(3, 6:9, 15)], levels)
# #Frequency of Each level of Factor
if(FALSE) bb |> count(churn) |> arrange(desc(n))
# #Coding for Dummy Variables
if(FALSE) contrasts(bb$Married) 
# #Vector of all column classes
if(FALSE) bb |> {\(x) vapply(x, class, character(1))}()
```


## Kite

### Undirected and Directed Graphs

- \textcolor{pink}{Undirected}: $\quad A[i, j] = 1 \quad\Rightarrow\quad A[j, i] = 1$
- \textcolor{pink}{Directed} &nbsp; &nbsp; &nbsp;: $\quad A[i, j] = 1 \quad\nRightarrow\quad A[j, i] = 1$

### iGraph & Adjacency Matrix

- \textcolor{pink}{iGraph} object description has 4 letters and 2 numbers
  - D or U, for a directed or undirected graph
  - N for a named graph (where nodes have a \textcolor{pink}{name} attribute)
  - W for a weighted graph (where edges have a \textcolor{pink}{weight} attribute)
  - B for a bipartite (two-mode) graph (where nodes have a \textcolor{pink}{type} attribute)
  - Numbers: Nodes (or Vertices) and Edges
  - The description also lists node & edge attributes, for example:
    - (g/c) - graph-level character attribute
    - (v/c) - vertex-level character attribute
    - (e/n) - edge-level numeric attribute


```{r 'P01-iGraph-Kite'}
bb <- p01kite
# #Get iGraph (Undirected) from Adjacency Matrix
u_kite <- graph_from_adjacency_matrix(bb, mode = "undirected")
u_kite
#
# #Get iGraph (Directed) from Adjacency Matrix
d_kite <- graph_from_adjacency_matrix(bb, mode = "directed")
d_kite
#
kite <- u_kite
class(kite)
#
# #Get Adjacency Matrix from iGraph (Undirected)
ii <- as_adjacency_matrix(u_kite, type = "both", sparse = FALSE)
# #Get Adjacency Matrix from iGraph (Directed)
jj <- as_adjacency_matrix(d_kite, sparse = FALSE)
stopifnot(all(identical(bb, ii), identical(bb, jj)))
```

### Vertices

```{r 'P01-Vertices-Kite'}
# #Count Vertices
vcount(kite)
#
# #Named Vector of Vertices
V(kite)
```

### Edges

```{r 'P01-Edges-Kite'}
# #Count Edges
ecount(kite)
#
# #Named Vector of Edges
E(kite)
```

### Edgelist & iGraph

```{r 'P01-EdgeList-Kite'}
bb <- kite
#
# #Get Edgelist from iGraph
ii <- as_edgelist(bb, names = TRUE)
class(ii)
str(ii)
head(ii)
#
# #Get iGraph from Edgelist
jj <- graph_from_edgelist(ii, directed = TRUE)
#
kk <- attributes(E(bb))$vnames
ll <- attributes(E(jj))$vnames
stopifnot(identical(kk, ll))
#
ll
```

### Shortest Paths

- The \textcolor{pink}{shortest paths} matrix shows us the minimum number of edges between each member (degrees of separation)
  - The shortest path length from a vertex to itself is always zero. 


```{r 'P01-Shortest-Paths-Kite'}
# #Histogram of the shortest path length between each pair of vertices.
distance_table(kite, directed = TRUE)
#
# #Numeric matrix with length(to) columns and length(v) rows. 
distances(kite, mode = "all")
```


### Diameter

- The \textcolor{pink}{diameter} of a network tells us the number of edges between the most distant members
  - The diameter of a graph is the length of the longest geodesic.
  
```{r 'P01-Diameter-Kite'}
# #Diameter
diameter(kite)
#
# #Two vertex ids, the vertices which are connected by the diameter path.
farthest_vertices(kite)
```

### Reciprocity

- \textcolor{pink}{Reciprocity} is the ratio of the number of reciprocated edges to the number of total edges.

```{r 'P01-Reciprocity-Kite'}
# #Reciprocity
reciprocity(kite)
```

### Density or Clustering Coefficient

- The \textcolor{pink}{density} or 'Clustering Coefficient' of a graph is the ratio of the number of edges and the number of possible edges.


```{r 'P01-Density-Kite'}
# #Density
edge_density(kite)
```


### Network {.tabset .tabset-fade}

#### Plot {.unlisted .unnumbered}

```{r 'P01-Plot-Kite', include=FALSE}
set.seed(3)
hh <- kite
#
# #Layout: Fruchterman Reingold or Kamada Kawai
lay_hh <- layout_with_fr(hh) #layout_with_kk(hh) layout_with_fr(hh)
#
# #Use Degrees of each node to indicate size
size_m <- 5L 
size_hh <- degree(hh, mode = "all") * size_m
#
# #Distances of ALL Nodes from the Specified Node i.e. "D"
away_d <- distances(hh, v = V(hh)["D"], to = V(hh))
# #Get a Vector of same length with Maximum Unique Colors & accounting for 0 index
v_col_hh <- viridis(max(away_d) + 1, direction = -1)[away_d + 1]
v_lbl_col_hh <- c(rep("black", vcount(hh)-3), rep("white", 3))
#
# #Get Diameter Path
far_hh <- farthest_vertices(hh)$vertices
dia_hh <- shortest_paths(hh, from = V(hh)[far_hh[1]], to  = V(hh)[far_hh[2]], output = "both")
#
# #Edge color
e_col_hh <- rep("gray", ecount(hh))
e_col_hh[unlist(dia_hh$epath)] <- "orange"
# #Edge width
e_w_hh <- rep(2, ecount(hh))
e_w_hh[unlist(dia_hh$epath)] <- 4
# #Node color for the Path
#vcol <- rep("gray", vcount(hh))
#vcol[unlist(dia_hh$vpath)] <- "gold"
#
# #Colour Legend
lgd_col_hh <- tibble(Text = unique(as.vector(away_d)), Fill = unique(v_col_hh)) |> arrange(Text)
lgd_ttl_col_hh <- "Distance"
# #Size Legend
lgd_size_hh <- sort(unique(size_hh))/size_m
lgd_ttl_size_hh <- "Degree"
#
ttl_hh <- "Krackhardt Kite: Degrees, Diameter, and Distances from D" 
cap_hh <- "P01I01"
loc_png <- here("images", "P01I01-Kite.png") 
#
if(!file.exists(loc_png)) {
  png(filename = loc_png, width = q_png_w, height = q_png_h, units = "in", res = q_dpi)
  #dev.control('enable') 
  plot(hh, layout = lay_hh, 
       vertex.size = size_hh, vertex.color = v_col_hh, vertex.label.color = v_lbl_col_hh, 
       edge.color = e_col_hh, edge.width = e_w_hh)
  legend(x = "topleft", inset = 0.2, legend = lgd_col_hh$Text, pt.bg = lgd_col_hh$Fill, 
         pch = 21, pt.cex = 3, cex = 1.3, title = lgd_ttl_col_hh)
  legend(x = "topleft", legend = seq.int(lgd_size_hh), pt.cex = lgd_size_hh, 
         pch = 1, cex = 1.3, x.intersp = 1.5, y.intersp = 1.5, title = lgd_ttl_size_hh)
  title(main = ttl_hh, line = 3, adj = 0)
  title(sub = cap_hh, line = 4, adj = 1)
  P01 <- recordPlot()
  dev.off()
  assign(cap_hh, P01)
  rm(P01)
  #eval(parse(text = cap_hh))
}
```

```{r 'P01I01', echo=FALSE, fig.cap="(P01I01) Krackhardt Kite"}
include_graphics(here("images", "P01I01-Kite.png"))
```

#### Code {.unlisted .unnumbered}

```{r 'P01-Plot-Kite-A', eval=FALSE, ref.label=c('P01-Plot-Kite')}
#
```

### Centrality

#### Degree Centrality

- The \textcolor{pink}{degree} of a vertex is the number connections (adjacent edges) for a node

```{r 'P01-Centrality-Degree-Kite'}
# #Vector of each Vertex Degree: mode = c("all", "out", "in", "total")
degree(kite, mode = "all")
```

#### Closeness Centrality

- \textcolor{pink}{Closeness centrality} measures how many steps is required to access every other vertex from a given vertex.
  - Normalized closeness centrality shows the inverse of the number of edges to all other nodes in the graph (e.g. a value of .5 means an average of two edges)

```{r 'P01-Centrality-Closeness-Kite'}
# #Vector of each Vertex Closeness: mode = c("all", "out", "in", "total")
closeness(kite, mode = "all", normalized = TRUE) |> round(3)
```

#### Betweenness Centrality

- \textcolor{pink}{Betweenness centrality} shows the number of shortest paths a node is on between pairs of other nodes. 
  - If multiple shortest paths between two nodes exist the betweenness is shared among all the intermediate nodes

```{r 'P01-Centrality-Betweenness-Kite'}
# #Betweenness returns a 'communities' object
ii <- cluster_edge_betweenness(kite, directed = TRUE) 
class(ii)
ii
```

#### Eigenvector Centrality or Pagerank

- \textcolor{pink}{Eigenvector centrality} or Pagerank scores correspond to the values of the first eigenvector of the graph adjacency matrix; these scores may, in turn, be interpreted as arising from a reciprocal process in which the centrality of each actor is proportional to the sum of the centralities of those actors to whom he or she is connected. 
  - In general, vertices with high eigenvector centralities are those which are connected to many other vertices which are, in turn, connected to many others.
  - It is a recursive measure of centrality, measuring each node by not only the number of connections it has, but weighting that metric by how many connections its connections have, which are in turn weighted by their connections etc. 


```{r 'P01-Centrality-Eigenvector-Kite'}
# #List of Eigenvector and Eigenvalue Score
ii <- eigen_centrality(kite, directed = TRUE) 
#
# #Eigenvector of each Vertex
ii$vector |> round(3)
#
# #Eigenvalue Score
ii$value
```

#### Degree & Eigenvalue

- Residual of Simple Linear Regression can be used to size the nodes in our network. This may identify nodes which are connected to only a few nodes, which are "important" i.e. they have high eigenvector centrality.

```{r 'P01-Degree-Eigenvector-Kite'}
ii_deg <- degree(kite, mode = "all")
ii_egn <- eigen_centrality(kite, directed = TRUE)$vector
# #Tibble
ii <- tibble(Vertices = names(ii_deg), Degree = ii_deg, Eigen = ii_deg)
# #Regression
ii_res <- lm(Eigen ~ Degree, data = ii)$residuals |> round(7)
# #Add Residuals
ii <- ii |> add_column(Residual = ii_res)
```

### Cliques

- \textcolor{pink}{Cliques} are sets of nodes which are all connected to one another. 
  - NOTE: Directed graphs will be considered as Undirected ones for Cliques calculation

```{r 'P01-Cliques-Kite'}
# #Max Cliques 
ii <- max_cliques(as.undirected(kite))
# #Get Max Length of List Elements
jj <- max(vapply(ii, length, integer(1)))
# #Get Logical Vector filter for the matching length
kk <- vapply(ii, function(x) length(x) == jj, logical(1))
# #subset
ll <- ii[kk]
#
mm <- largest_cliques(as.undirected(kite)) 
mm
#
# #It if unknown why both are not identical
if(FALSE) {
  identical(ll, mm)
  ll
  mm
  str(ll)
  str(mm)
  attributes(ll)
  attributes(mm)
}
```

## Validation {#val-p01 .unlisted .unnumbered .tabset .tabset-fade}

```{r 'P01-Cleanup', include=FALSE, cache=FALSE}
if(FALSE) f_rmExist(aa, bb, ii, jj, kk, ll, loc_rds, loc_src, names_ii, p01km_1, p01km_4)
```

```{r 'P01-Validation', include=TRUE, cache=FALSE}
# #SUMMARISED Packages and Objects (BOOK CHECK)
f_()
#
difftime(Sys.time(), q_start)
```

****
