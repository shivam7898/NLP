# NLP Basics {#p01}

```{r 'P01', include=FALSE, cache=FALSE}
sys.source(here::here("code", "A00Knitr.R"), envir = knitr::knit_global())
sys.source(here::here("code", "A01Packages.R"), envir = knitr::knit_global())
sys.source(here::here("code", "A02AllUDF.R"), envir = knitr::knit_global())
reticulate::source_python(here::here("code", "B01Modules.py"))
```

## Data: Krackhardt Kite {#kite-p01 .tabset .tabset-fade}

### Glance {.unlisted .unnumbered}

\textcolor{pink}{Please import the "P01-KM-Week1.xlsx" and "P01-KM-Week4.xlsx"}

- About: 18 Edges and 10 Vertices

```{r 'P01-CSV-Kite', include=FALSE}
loc_src <- here("data", "P01-Kite.csv")
loc_rds <- here("data", "P01-Kite.rds")
if(FALSE | !file.exists(loc_rds)) {
  # #Read Adjacency Matrix from CSV
  aa <- read_csv(loc_src, show_col_types = FALSE)
  # #Columns To RowNames | Named Matrix |
  aa <- aa |> 
    column_to_rownames(var = "Nodes") |> 
    as.matrix.data.frame(rownames.force = TRUE)
  # #Save
  p01kite <- aa
  saveRDS(p01kite, loc_rds)
} else { 
  p01kite <- aa <- readRDS(loc_rds)
}
```

```{r 'P01-Structure-Kite'}
str(p01kite)
```

### Import {.unlisted .unnumbered}

```{r 'P01-CSV-Kite-A', eval=FALSE, ref.label=c('P01-CSV-Kite')}
# #Ref another file chunk
```


## Data: KM Network {#km-p01 .tabset .tabset-fade}

### Glance {.unlisted .unnumbered}

\textcolor{pink}{Please import the "P01-KM-Week1.xlsx" and "P01-KM-Week4.xlsx"}

- About: Edges and Vertices of a Class Network at Week 1 and Week 4

```{r 'P01-XL-KM-1', include=FALSE}
loc_src <- here("data", "P01-KM-Week1.xlsx")
loc_rds <- here("data", "P01-KM-Week1.rds")
if(FALSE | !file.exists(loc_rds)) {
  names_aa <- c("Edges", "Vertices")
  # #Verify Excel
  stopifnot(identical(excel_sheets(loc_src), names_aa))
  # #Empty Named List
  aa <- setNames(vector("list", length(names_aa)), nm = names_aa)
  # #Read Excel Sheets
  aa$Edges    <- read_excel(path = loc_src, sheet = "Edges")
  aa$Vertices <- read_excel(path = loc_src, sheet = "Vertices")
  #
  # #Clean Edges
  names_bb <- c("Node_1", "Node_2", "Recognition", "Friendship")
  # #Rename | To Factor |
  bb <- aa$Edges |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(starts_with("vertex_"), factor)) |> 
    mutate(across(c(recognition, friendship), factor, levels = c(0, 1), labels = c("No", "Yes")))
  # #Rename
  names(bb) <- names_bb
  aa$Edges <- bb
  #
  # #Clean Vertices
  names_bb <- c("Node", "Gender", "Status", "ACCT", "IE", "MS_MIS", "MBA", "Group", "Major")
  # #Rename | Replace NA | Replace x | To Factor |
  bb <- aa$Vertices |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~ replace_na(., "No"))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~gsub("x", "Yes", .))) |> 
    mutate(across(where(is.character), factor))
  # #Rename
  names(bb) <- names_bb
  aa$Vertices <- bb
  #
  # #Save
  p01km_1 <- aa
  saveRDS(p01km_1, loc_rds)
} else { 
  p01km_1 <- aa <- readRDS(loc_rds)
}
```


```{r 'P01-XL-KM-4', include=FALSE}
loc_src <- here("data", "P01-KM-Week4.xlsx")
loc_rds <- here("data", "P01-KM-Week4.rds")
if(FALSE | !file.exists(loc_rds)) {
  names_aa <- c("Edges", "Vertices")
  # #Verify Excel
  stopifnot(identical(excel_sheets(loc_src), names_aa))
  # #Empty Named List
  aa <- setNames(vector("list", length(names_aa)), nm = names_aa)
  # #Read Excel Sheets
  aa$Edges    <- read_excel(path = loc_src, sheet = "Edges")
  aa$Vertices <- read_excel(path = loc_src, sheet = "Vertices")
  #
  # #Clean Edges
  names_bb <- c("Node_1", "Node_2", "Recognition", "Friendship")
  # #Rename | To Factor |
  bb <- aa$Edges |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(starts_with("vertex_"), factor)) |> 
    mutate(across(c(recognition, friendship), factor, levels = c(0, 1), labels = c("No", "Yes")))
  # #Rename
  names(bb) <- names_bb
  aa$Edges <- bb
  #
  # #Clean Vertices
  names_bb <- c("Node", "Gender", "Status", "ACCT", "IE", "MS_MIS", "MBA", "Group", "Major")
  # #Rename | Replace NA | Replace x | To Factor |
  bb <- aa$Vertices |> rename_with(make.names) |> 
    rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~ replace_na(., "No"))) |> 
    mutate(across(c(acct, ie, ms_mis, mba), ~gsub("x", "Yes", .))) |> 
    mutate(across(where(is.character), factor))
  # #Rename
  names(bb) <- names_bb
  aa$Vertices <- bb
  #
  # #Save
  p01km_4 <- aa
  saveRDS(p01km_4, loc_rds)
} else { 
  p01km_4 <- aa <- readRDS(loc_rds)
}
```

```{r 'P01-Dimensions-KM'}
# #Dimensions of Each Sheet: Row 1 (Rows), Row 2 (Columns), Columns (Sheets)
vapply(p01km_1, dim, numeric(2))
vapply(p01km_4, dim, numeric(2))
```

### Structure {.unlisted .unnumbered}

```{r 'P01-Structure-KM'}
str(p01km_1)
str(p01km_4)
```

### Summary {.unlisted .unnumbered}

```{r 'P01-Summary-KM'}
# #Summary of List Objects
lapply(p01km_1, summary)
lapply(p01km_4, summary)
```

### Import {.unlisted .unnumbered}

```{r 'P01-XL-KM-1-A', eval=FALSE, ref.label=c('P01-XL-KM-1')}
# #Ref another file chunk
```

```{r 'P01-XL-KM-4-A', eval=FALSE, ref.label=c('P01-XL-KM-4')}
# #Ref another file chunk
```

### ETC {.unlisted .unnumbered}

```{r 'P01-ETC', include=TRUE, eval=FALSE}
# #Count NA in Columns
if(FALSE) colSums(is.na(bb)) |> as_tibble(rownames = "Cols") |> filter(value > 0)
# #Subset Rows
if(FALSE) bb |> select(1) |> slice(1:10)
# #Comma separated string having each item within quotes for easy pasting as character not objects
if(FALSE) cat('"', paste0(names(which(sapply(bb, is.factor))), collapse = '", "'), '"\n', sep = '')
if(FALSE) cat('"', paste0(levels(bb$Arrival), collapse = '", "'), '"\n', sep = '')
# #Filter
if(FALSE) bb |> filter(is.na(account_length)) |> select(churn, account_length, vmail_plan)
# #Count Yes/No or True/False in ALL such Columns
if(FALSE) bb |> select(churn) |> 
  pivot_longer(everything()) |> count(name, value) |> 
  pivot_wider(names_from = value, values_from = n)
# #Count Unique of all Columns to decide which should be Factors
if(FALSE) bb |> summarise(across(everything(), ~ length(unique(.)))) |> pivot_longer(everything())
# #Summary of Columns of a class: is.factor is.numeric is.character
if(FALSE) bb |> select(where(is.factor)) |> summary()
# #Names and Indices of Columns of class: is.factor is.numeric is.character
if(FALSE) which(sapply(bb, is.factor))
# #Levels of Factor Columns
if(FALSE) lapply(bb[c(3, 6:9, 15)], levels)
# #Frequency of Each level of Factor
if(FALSE) bb |> count(churn) |> arrange(desc(n))
# #Coding for Dummy Variables
if(FALSE) contrasts(bb$Married) 
# #Vector of all column classes
if(FALSE) bb |> {\(x) vapply(x, class, character(1))}()
```


## Network

```{definition 'Network'}
A \textcolor{pink}{network} is a collection of entities and their relationships to one another. The entities that are connected are called \textcolor{pink}{nodes (vertices)}. The connections between the vertices are called \textcolor{pink}{edges (links)}.
```


## Kite

### Undirected and Directed Graphs

- \textcolor{pink}{Undirected}: $\quad A[i, j] = 1 \quad\Rightarrow\quad A[j, i] = 1$
- \textcolor{pink}{Directed} &nbsp; &nbsp; &nbsp;: $\quad A[i, j] = 1 \quad\nRightarrow\quad A[j, i] = 1$

### iGraph & Adjacency Matrix

- \textcolor{pink}{iGraph} object description has 4 letters and 2 numbers
  - D or U, for a directed or undirected graph
  - N for a named graph (where nodes have a \textcolor{pink}{name} attribute)
  - W for a weighted graph (where edges have a \textcolor{pink}{weight} attribute)
  - B for a bipartite (two-mode) graph (where nodes have a \textcolor{pink}{type} attribute)
  - Numbers: Nodes (or Vertices) and Edges
  - The description also lists node & edge attributes, for example:
    - (g/c) - graph-level character attribute
    - (v/c) - vertex-level character attribute
    - (e/n) - edge-level numeric attribute


```{r 'P01-iGraph-Kite'}
bb <- p01kite
# #Get iGraph (Undirected) from Adjacency Matrix
u_kite <- graph_from_adjacency_matrix(bb, mode = "undirected")
u_kite
#
# #Get iGraph (Directed) from Adjacency Matrix
d_kite <- graph_from_adjacency_matrix(bb, mode = "directed")
d_kite
#
kite <- u_kite
class(kite)
#
# #Get Adjacency Matrix from iGraph (Undirected)
ii <- as_adjacency_matrix(u_kite, type = "both", sparse = FALSE)
# #Get Adjacency Matrix from iGraph (Directed)
jj <- as_adjacency_matrix(d_kite, sparse = FALSE)
stopifnot(all(identical(bb, ii), identical(bb, jj)))
```

### Layout

```{r 'P01-Layout-Kite'}
# #Attaching a default layout to the Network for ease of comparison
if(FALSE) {
  # #Generate a Layout Matrix of Coordinates
  set.seed(3)
  # #Layout: Fruchterman Reingold layout_with_fr () or Kamada Kawai layout_with_kk()
  ii <- round(layout_with_fr(kite), 1)
  dput(ii)
}
# #Attach Layout Coordinates as Graph Attribute
graph_attr(kite, "layout") <- matrix(c(9.8, 11.1, 9.3, 10.6, 11.9, 10.4, 11.5, 11.5, 12.1, 12.7, 
                                       6.1, 5.7, 6.9, 6.5, 6, 7.5, 7.1, 8.8, 10.6, 12), 
                                     ncol = 2, byrow = FALSE) 
```

### Vertices or Nodes

```{r 'P01-Vertices-Kite'}
# #Count Vertices
vcount(kite)
#
# #Named Vector of Vertices
V(kite)
```

### Edges or Links

```{r 'P01-Edges-Kite'}
# #Count Edges
ecount(kite)
#
# #Named Vector of Edges
E(kite)
```

### Edgelist & iGraph

```{r 'P01-EdgeList-Kite'}
bb <- kite
#
# #Get Edgelist from iGraph
ii <- as_edgelist(bb, names = TRUE)
class(ii)
str(ii)
head(ii)
#
# #Get iGraph from Edgelist
jj <- graph_from_edgelist(ii)
#
kk <- attributes(E(bb))$vnames
ll <- attributes(E(jj))$vnames
stopifnot(identical(kk, ll))
#
ll
```

### Shortest Paths

- The \textcolor{pink}{shortest paths} matrix shows us the minimum number of edges between each member (degrees of separation)
  - The shortest path length from a vertex to itself is always zero. 


```{r 'P01-Shortest-Paths-Kite'}
# #Histogram of the shortest path length between each pair of vertices.
distance_table(kite)
#
# #Numeric matrix with length(to) columns and length(v) rows. 
distances(kite, mode = "all")
```


### Diameter

- The \textcolor{pink}{diameter} of a network tells us the number of edges between the most distant members
  - The diameter of a graph is the length of the longest geodesic.
  
```{r 'P01-Diameter-Kite'}
# #Diameter
diameter(kite)
#
# #Two vertex ids, the vertices which are connected by the diameter path.
farthest_vertices(kite)
```

### Reciprocity

- \textcolor{pink}{Reciprocity} is the ratio of the number of reciprocated edges to the number of total edges.

```{r 'P01-Reciprocity-Kite'}
# #Reciprocity
reciprocity(kite)
```

### Density or Clustering Coefficient

- The \textcolor{pink}{density} or 'Clustering Coefficient' of a graph is the ratio of the number of edges and the number of possible edges.


```{r 'P01-Density-Kite'}
# #Density
edge_density(kite)
```


### Network {.tabset .tabset-fade}

#### Plot {.unlisted .unnumbered}

```{r 'P01-Plot-Kite', include=FALSE}
hh <- kite
#
# #Use Degrees of each node to indicate size
size_m <- 5L 
size_hh <- degree(hh, mode = "all") * size_m
#
# #Distances of ALL Nodes from the Specified Node i.e. "D"
away_d <- distances(hh, v = V(hh)["D"], to = V(hh))
# #Get a Vector of same length with Maximum Unique Colors & accounting for 0 index
v_col_hh <- viridis(max(away_d) + 1, direction = -1)[away_d + 1]
v_lbl_col_hh <- c(rep("black", vcount(hh)-3), rep("white", 3))
#
# #Get Diameter Path
far_hh <- farthest_vertices(hh)$vertices
dia_hh <- shortest_paths(hh, from = V(hh)[far_hh[1]], to  = V(hh)[far_hh[2]], output = "both")
#
# #Edge color
e_col_hh <- rep("gray", ecount(hh))
e_col_hh[unlist(dia_hh$epath)] <- "orange"
# #Edge width
e_w_hh <- rep(2, ecount(hh))
e_w_hh[unlist(dia_hh$epath)] <- 4
# #Node color for the Path
#v_col_hh <- rep("gray", vcount(hh))
#v_col_hh[unlist(dia_hh$vpath)] <- "gold"
#
# #Color Legend
lgd_col_hh <- tibble(Text = unique(as.vector(away_d)), Fill = unique(v_col_hh)) |> arrange(Text)
lgd_ttl_col_hh <- "Distance"
# #Size Legend
lgd_size_hh <- sort(unique(size_hh))/size_m
lgd_ttl_size_hh <- "Degree"
#
ttl_hh <- "Krackhardt Kite: Degrees, Diameter, and Distances from D" 
cap_hh <- "P01I01"
loc_png <- here("images", "P01I01-Kite.png") 
#
if(!file.exists(loc_png)) {
  png(filename = loc_png, width = q_png_w, height = q_png_h, units = "in", res = q_dpi)
  #dev.control('enable') 
  plot(hh, vertex.size = size_hh, vertex.color = v_col_hh, vertex.label.color = v_lbl_col_hh, 
       edge.color = e_col_hh, edge.width = e_w_hh)
  legend(x = "topleft", inset = 0.2, legend = lgd_col_hh$Text, pt.bg = lgd_col_hh$Fill, 
         pch = 21, pt.cex = 3, cex = 1.3, title = lgd_ttl_col_hh)
  legend(x = "topleft", legend = seq.int(lgd_size_hh), pt.cex = lgd_size_hh, 
         pch = 1, cex = 1.3, x.intersp = 1.5, y.intersp = 1.5, title = lgd_ttl_size_hh)
  title(main = ttl_hh, line = 3, adj = 0)
  title(sub = cap_hh, line = 4, adj = 1)
  P01 <- recordPlot()
  dev.off()
  assign(cap_hh, P01)
  rm(P01)
  #eval(parse(text = cap_hh))
}
```

```{r 'P01I01', echo=FALSE, fig.cap="(P01I01) Krackhardt Kite"}
include_graphics(here("images", "P01I01-Kite.png"))
```

#### Code {.unlisted .unnumbered}

```{r 'P01-Plot-Kite-A', eval=FALSE, ref.label=c('P01-Plot-Kite')}
#
```

### Centrality

#### Degree Centrality

- The \textcolor{pink}{degree} of a vertex is the number connections (adjacent edges) for a node

```{r 'P01-Centrality-Degree-Kite'}
# #Vector of each Vertex Degree: mode = c("all", "out", "in", "total")
degree(kite, mode = "all")
```

#### Closeness Centrality

- \textcolor{pink}{Closeness centrality} measures how many steps is required to access every other vertex from a given vertex.
  - Normalized closeness centrality shows the inverse of the number of edges to all other nodes in the graph (e.g. a value of .5 means an average of two edges)

```{r 'P01-Centrality-Closeness-Kite'}
# #Vector of each Vertex Closeness: mode = c("all", "out", "in", "total")
closeness(kite, mode = "all", normalized = TRUE) |> round(3)
```

#### Betweenness Centrality

- \textcolor{pink}{Betweenness centrality} shows the number of shortest paths a node is on between pairs of other nodes. 
  - If multiple shortest paths between two nodes exist the betweenness is shared among all the intermediate nodes

```{r 'P01-Centrality-Betweenness-Kite'}
# #Betweenness returns a 'communities' object
ii <- cluster_edge_betweenness(kite) 
attributes(ii)
str(ii)
#
# #Modularity
modularity(ii)
#
# #Group Sizes
sizes(ii)
#
# #Groups
setNames(ii$membership, nm = ii$names)
#
# #First Group
ii[[1]]
```

#### Eigenvector Centrality or Pagerank

- \textcolor{pink}{Eigenvector centrality} or Pagerank scores correspond to the values of the first eigenvector of the graph adjacency matrix; these scores may, in turn, be interpreted as arising from a reciprocal process in which the centrality of each actor is proportional to the sum of the centralities of those actors to whom he or she is connected. 
  - In general, vertices with high eigenvector centralities are those which are connected to many other vertices which are, in turn, connected to many others.
  - It is a recursive measure of centrality, measuring each node by not only the number of connections it has, but weighting that metric by how many connections its connections have, which are in turn weighted by their connections etc. 


```{r 'P01-Centrality-Eigenvector-Kite'}
# #List of Eigenvector and Eigenvalue Score
ii <- eigen_centrality(kite) 
#
# #Eigenvector of each Vertex
ii$vector |> round(3)
#
# #Eigenvalue Score
ii$value
```

#### Degree & Eigenvalue

- Residual of Simple Linear Regression can be used to size the nodes in our network. This may identify nodes which are connected to only a few nodes, which are "important" i.e. they have high eigenvector centrality.

```{r 'P01-Degree-Eigenvector-Kite'}
bb <- kite
ii_deg <- degree(bb, mode = "all")
ii_egn <- eigen_centrality(bb)$vector
# #Tibble
ii <- tibble(Vertices = names(ii_deg), Degree = ii_deg, Eigen = ii_egn)
# #Regression
ii_res <- lm(Eigen ~ Degree, data = ii)$residuals |> round(7)
# #Add Residuals
ii |> add_column(Residual = ii_res) |> mutate(Size = abs(Residual)*100)
```

### Cliques {.tabset .tabset-fade}

- \textcolor{pink}{Cliques} are sets of nodes which are all connected to one another. 
  - To be included in a clique, a node must be tied to all other nodes in the clique.
  - A \textcolor{pink}{k-core} is a group where nodes have k edges within the group.
    - The k-core of graph is a maximal subgraph in which each vertex has at least degree k. 
    - The coreness of a vertex is k if it belongs to the k-core but not to the (k+1)-core.
    - Two nodes with coreness of 3 may not be connected at all and may be in separate k-cores.
  - NOTE: Directed graphs will be considered as Undirected ones for Cliques calculation
  

```{r 'P01-Cliques-Kite'}
bb <- kite
# #Max Cliques with Lengths
summary(max_cliques(bb))[, 1]
#
# #Largest Cliques
largest_cliques(bb)
#
# #Coreness
coreness(bb)
```

#### Plot {.unlisted .unnumbered}

```{r 'P01-Plot-Kite-Cliques', include=FALSE}
hh <- kite
#
# #Get Largest Cliques
cliq_hh <- largest_cliques(hh)
# #Color Cliques
pal_hh <- viridis(length(cliq_hh) + 1) #Palette
v_col_hh <- rep(last(pal_hh), vcount(hh))
v_col_hh[cliq_hh[[1]]] <- pal_hh[1]
v_col_hh[cliq_hh[[2]]] <- pal_hh[2]
#
# #Text Label Color
v_lbl_col_hh <- c(rep("black", vcount(hh)))
v_lbl_col_hh[cliq_hh[[1]]] <- "white"
v_lbl_col_hh[cliq_hh[[2]]] <- "white"
#
ttl_hh <- "Krackhardt Kite: Cliques" 
cap_hh <- "P01I02"
loc_png <- here("images", "P01I02-Kite-Cliques.png") 
#
if(!file.exists(loc_png)) {
  png(filename = loc_png, width = q_png_w, height = q_png_h, units = "in", res = q_dpi)
  #dev.control('enable') 
  plot(hh, vertex.color = v_col_hh, vertex.label.color = v_lbl_col_hh, mark.groups = cliq_hh)
  title(main = ttl_hh, line = 3, adj = 0)
  title(sub = cap_hh, line = 4, adj = 1)
  P01 <- recordPlot()
  dev.off()
  assign(cap_hh, P01)
  rm(P01)
  #eval(parse(text = cap_hh))
}
```

```{r 'P01I02', echo=FALSE, fig.cap="(P01I02) Krackhardt Kite: Cliques"}
include_graphics(here("images", "P01I02-Kite-Cliques.png"))
```

#### Code {.unlisted .unnumbered}

```{r 'P01-Plot-Kite-Cliques-A', eval=FALSE, ref.label=c('P01-Plot-Kite-Cliques')}
#
```

## Community Detection & Modularity

- Popular algorithms for finding structure in large graphs
  - \textcolor{pink}{Walktrap} algorithm 
    - It detects communities through a series of short random walks, with the idea that the nodes encountered on any given random walk are more likely to be within a community than not. 
    - While edge betweenness started with the whole network and removed edges to create clusters, this algorithm initially treats all nodes as communities of their own, then merges them into communities, and these communities into larger communities, and so on.
  - \textcolor{pink}{Fast Greedy} algorithm 
    - The time walktrap algorithm takes to run grows with the square of the number of nodes times the number of edges $O(|V| |E|^2)$. 
    - Fast greedy algorithm takes less time to run as the network size increases $O(|V| |E| \log{|V|})$.
- \textcolor{pink}{Modularity} is one way to measure of the success of a community finding algorithm. 
  - The higher the modularity, the more dense edges within groups are and the more sparse edges reaching outside of the groups are. i.e. \textcolor{pink}{Higher is Better}.


```{r 'P01-Community'}
bb <- kite
# #Betweenness Centrality: Slow
btw <- cluster_edge_betweenness(bb) 
# #Modularity
modularity(btw) |> round(3)
# #Group Sizes
sizes(btw)
# #Groups
setNames(btw$membership, nm = btw$names)
#
# #Walktrap Algorithm
walk <- cluster_walktrap(bb)
# #Modularity
modularity(walk) |> round(3)
# #Group Sizes
sizes(walk)
# #Groups
setNames(walk$membership, nm = walk$names)
#
# #Fast Greedy Algorithm
greed <- cluster_fast_greedy(bb)
# #Modularity
modularity(greed) |> round(3)
# #Group Sizes
sizes(greed)
# #Groups
setNames(greed$membership, nm = greed$names)
```

### Algorithms {.tabset .tabset-fade}

#### Plot {.unlisted .unnumbered}

```{r 'P01-Plot-Kite-Communities', include=FALSE}
hh <- kite
hh_b <- cluster_edge_betweenness(hh) 
hh_w <- cluster_walktrap(hh)
hh_g <- cluster_fast_greedy(hh)
#
#ttl_hh <- "Krackhardt Kite: Communities" 
ttl_hh_b <- "Kite: Betweenness" 
ttl_hh_w <- "Kite: Walktrap" 
ttl_hh_g <- "Kite: Fast Greedy" 
cap_hh <- "P01I03"
loc_png <- here("images", "P01I03-Kite-Communities.png") 
#
if(!file.exists(loc_png)) {
  png(filename = loc_png, width = q_png_w_w, height = q_png_w_h, units = "in", res = q_dpi_w)
  #dev.control('enable') 
  def_par <- par(no.readonly = TRUE) #Save Default
  par(mfrow = c(2, 3), mar = c(0,0,0,0))
  plot(x = hh_b, y = hh)
  title(main = ttl_hh_w, line = -2, adj = 0.5)
  plot(x = hh_w, y = hh)
  title(main = ttl_hh_b, line = -2, adj = 0.5)
  plot(x = hh_g, y = hh)
  title(main = ttl_hh_g, line = -2, adj = 0.5)
  plot_dendrogram(x = hh_b, cex = 2)
  plot_dendrogram(x = hh_w, cex = 2)
  plot_dendrogram(x = hh_g, cex = 2)
  par(def_par)  #Reset Default
  title(sub = cap_hh, line = 4, adj = 1)
  P01 <- recordPlot()
  dev.off()
  #par(mfrow = c(1, 1)) #Default
  assign(cap_hh, P01)
  rm(P01)
  #eval(parse(text = cap_hh))
}
```

```{r 'P01I03', echo=FALSE, out.width='100%', fig.cap="(P01I03) Krackhardt Kite: Communities"}
include_graphics(here("images", "P01I03-Kite-Communities.png"))
```

#### Code {.unlisted .unnumbered}

```{r 'P01-Plot-Kite-Communities-A', eval=FALSE, ref.label=c('P01-Plot-Kite-Communities')}
#
```


## Validation {#val-p01 .unlisted .unnumbered .tabset .tabset-fade}

```{r 'P01-Cleanup', include=FALSE, cache=FALSE}
if(FALSE) f_rmExist(aa, bb, ii, jj, kk, ll, loc_rds, loc_src, names_ii, p01km_1, p01km_4)
```

```{r 'P01-Validation', include=TRUE, cache=FALSE}
# #SUMMARISED Packages and Objects (BOOK CHECK)
f_()
#
difftime(Sys.time(), q_start)
```

****
